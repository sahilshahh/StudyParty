<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>FAC Map</title>
	<!-- Styles -->
	<link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='css/demostyles.css') }}" async>
	<link href="https://fonts.googleapis.com/css?family=Lora|Nunito" rel="stylesheet" async>
	<svg style="height:0;">
		<defs>
			<rect id="vert_box" x="1" y="-.1" width="98" height="100.2" rx="24.5" ry="24.5"/>
			<rect id="hor_box" x="-.1" y="1" width="100.2" height="98" rx="24.5" ry="24.5"/>
			<mask id="border_mask">
				<rect width="100" height="100" fill="white"/>
				<use href="#vert_box"/>
				<use href="#hor_box"/>
			</mask>
			<clipPath id="border_clip">
				<use href="#vert_box"/>
				<use href="#hor_box"/>
			</clipPath>
			<symbol id="ct" class="layer" fill="rgba(250,230,177,1)" viewbox="0 0 100 100" preserveAspectRatio="xMidYMid meet">
				<defs>
					<!-- shadow filter -->
					<filter id="f_shadow" x="-50%" y="-50%" width="200%" height="200%" primitiveUnits="objectBoundingBox">
						<feColorMatrix
							result="darken"
							in="offOut"
							type="matrix"
							values="0.4 0 0 0 0
											0 0.4 0 0 0
											0 0 0.4 0 0
											0 0 0 1 0" />
						<!-- <feGaussianBlur result="blurOut" in="darken" stdDeviation=".05"/> -->
					</filter>
					<!--  darken filter -->
					<filter id="f_darken" x="0" y="0" width="100%" height="100%">
						<feColorMatrix
							in="SourceGraphic"
							type="matrix"
							values="0.02 0 0 0 0
											0 0.02 0 0 0
											0 0 0.02 0 0
											0 0 0 1 0" />
					</filter>
					<!-- 	bottom gradient	 -->
					<radialGradient id="radial" cx="50%" cy="50%" r="50%" fx="0%" fy="50%" gradientTransform="translate(.5,0)">
						<stop offset="0%" stop-color="rgba(255,255,255,.1)"/>
						<stop offset="100%" stop-color="rgba(255,255,255,0)"/>
					</radialGradient>
					<!-- 	glare	 -->
					<symbol id="glare" fill="rgba(255,255,255,.5)" viewbox="0 0 28 32" preserveAspectRatio="none">
						<rect x="-1" y="-10" width="2" height="20" transform="translate(16,10) rotate(10) skewX(-30)"/>
						<rect x="-.25" y="-10" width=".5" height="20" transform="translate(10,15) rotate(10) skewX(-30)"/>
						<rect x="-2" y="-10" width="4" height="30" fill="rgba(255,255,255,.2)" transform="translate(18,13) rotate(10) skewX(-30)"/>
					</symbol>
					<!-- clip for glare -->
					<clipPath id="glare_clip">
						<ellipse id="glare_clip_def" cx="50" cy="0" rx="50" ry="50" transform="translate(0,6.7) scale(1,.5)"/>
					</clipPath>
				</defs>
				<!-- 	shadow	 -->
				<ellipse id="shadow" cx="50" cy="50" rx="50" ry="50" transform="translate(0,0) scale(.7,.7) scale(1,.5)" fill="rgba(38,34,22,.1)"/>
				<!-- 	bottom	 -->
				<ellipse id="bottom1" cx="50" cy="50" rx="50" ry="50" fill="rgb(38,34,22)" transform="translate(0,0) scale(.5,.5) scale(1,.5)"/>
				<ellipse id="bottom2" cx="50" cy="50" rx="50" ry="50" fill="url(#radial)" transform="translate(0,0) scale(.5,.5) scale(1,.5)"/>
				<!-- 	leg	 -->
				<rect id="leg" width="15" height="50" rx="6" x="50" y="0" transform="translate(-7.5,6.7) scale(1,0.866)" fill="rgb(38,34,22)"/>
				<!-- 	edge	 -->
				<ellipse id="edge" cx="50" cy="0" rx="50" ry="50" transform="translate(0,6.7) matrix(1,0,0,1.02,0,.8485) scale(1,.5)" fill="rgba(0,0,0,1)"/>
				<!-- 	top	 -->
				<ellipse id="top" cx="50" cy="0" rx="50" ry="50" transform="translate(0,6.7) scale(1,.5)"/>
				<!-- glare -->
				<g clip-path="url(#glare_clip)">
					<!-- "contain and clip" trick-->
					<use id="glare_instance" xlink:href="#glare" width="100" height="50" y="-25" transform="translate(0,25) translate(0,-20.71) scale(1,1)"/>
				</g>
			</symbol>
		</defs>
		
		<rect id="cb" width="100" height="100" rx="25" ry="25" mask="url(#border_mask)"/>

		<symbol id="g" viewbox="-50 -50 100 100" fill="none">
			<g id="hor">
				<path d="M-150,0 C-150,-65 150,-65 150,0" />
				<path d="M-150,0 C-150,-55 150,-55 150,0" />
				<path d="M-150,0 C-150,-45 150,-45 150,0" />
				<path d="M-150,0 C-150,-35 150,-35 150,0" />
				<path d="M-150,0 C-150,-25 150,-25 150,0" />
				<path d="M-150,0 C-150,-15 150,-15 150,0" />
				<path d="M-150,0 C-150,-5 150,-5 150,0" />
				<path d="M-150,0 C-150,5 150,5 150,0" />
				<path d="M-150,0 C-150,15 150,15 150,0" />
				<path d="M-150,0 C-150,25 150,25 150,0" />
				<path d="M-150,0 C-150,35 150,35 150,0" />
				<path d="M-150,0 C-150,45 150,45 150,0" />
				<path d="M-150,0 C-150,55 150,55 150,0" />
				<path d="M-150,0 C-150,65 150,65 150,0" />
			</g>
			<g id="vert">
				<path d="M0,-150 C-65,-150 -65,150 0,150" />
				<path d="M0,-150 C-55,-150 -55,150 0,150" />
				<path d="M0,-150 C-45,-150 -45,150 0,150" />
				<path d="M0,-150 C-35,-150 -35,150 0,150" />
				<path d="M0,-150 C-25,-150 -25,150 0,150" />
				<path d="M0,-150 C-15,-150 -15,150 0,150" />
				<path d="M0,-150 C-5,-150 -5,150 0,150" />
				<path d="M0,-150 C5,-150 5,150 0,150" />
				<path d="M0,-150 C15,-150 15,150 0,150" />
				<path d="M0,-150 C25,-150 25,150 0,150" />
				<path d="M0,-150 C35,-150 35,150 0,150" />
				<path d="M0,-150 C45,-150 45,150 0,150" />
				<path d="M0,-150 C55,-150 55,150 0,150" />
				<path d="M0,-150 C65,-150 65,150 0,150" />
			</g>
	</symbol>
	</svg>
	<style>
		#dot {
			position: absolute;
			top: 0px;
			left: 0px;
			z-index: 2;
		}
	</style>
</head>
<body
<div class="container-full">
    <div class="row">
        <div class="dropdown">
  			<button class="dropbtn">Buildings</button>
  			<div class="dropdown-content">
  				{%for item in buildings%}
				    <a href="{{url_for('index', building = item)}}">{{item.replace('*','')}}</a>
				{%endfor%}
  			</div>
		</div>
		<button class="dropbtn" onclick="location.href='{{url_for('upload')}}'">Upload</button>
    </div>
    <!-- /row -->
</div>
<header>
	<span class="highlight-white line-bg">FAC</span>
</header>
<main>
	<div id="map-container">
		<!-- 147.64587/114.39804 = 1.290633 -->
		<img id="map" src="{{ url_for('static', filename='img/FAC.svg') }}" width="150%">
		<svg id="furniture" width="150%" viewbox="0 0 640 495.88" preserveAspectRatio="xMinYMin meet">
			<use href="#ct" width="20" height="20" x="205.4" y="348" transform="translate(-10,-10)"/>
			<use href="#ct" width="20" height="20" x="234.1" y="324" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="291.7" y="372" transform="translate(-10,-10)"/>
			<use href="#ct" width="20" height="20" x="320.5" y="348" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="349.3" y="324" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="406.9" y="372" transform="translate(-10,-10)"/>
			<use href="#ct" width="20" height="20" x="435.7" y="348" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="263" y="198.5" transform="translate(-10,-10)"/>
			<use href="#ct" width="20" height="20" x="263" y="298.5" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="291.7" y="174" transform="translate(-10,-10)"/>
			<use href="#ct" width="20" height="20" x="320.5" y="150" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="349.3" y="126" transform="translate(-10,-10)"/>

			<use href="#ct" width="20" height="20" x="406.9" y="174" transform="translate(-10,-10)"/>
			<use href="#ct" width="20" height="20" x="435.7" y="150" transform="translate(-10,-10)"/>
		</svg>
		<img id="dot" src="{{ url_for('static', filename='img/dot.svg') }}" width="30" height="30">
	</div>
	<svg id="left-top" class="corner-border" viewbox="0 0 24.5 24.5" preserveAspectRatio="xMinYMin meet">
		<use x="0" y="0" width="100" height="100" href="#cb"/>
	</svg>
	<svg id="right-top" class="corner-border" viewbox="0 0 24.5 24.5" preserveAspectRatio="xMinYMin meet">
		<use x="-75.5" y="0" width="100" height="100" href="#cb"/>
	</svg>
	<svg id="left-bottom" class="corner-border" viewbox="0 0 24.5 24.5" preserveAspectRatio="xMinYMin meet">
		<use x="-0" y="-75.5" width="100" height="100" href="#cb"/>
	</svg>
	<svg id="right-bottom" class="corner-border" viewbox="0 0 24.5 24.5" preserveAspectRatio="xMinYMin meet">
		<use x="-75.5" y="-75.5" width="100" height="100" href="#cb"/>
	</svg>
	<svg id="grid" viewbox="0 0 100 100" preserveAspectRatio="xMidYMid slice">
		<use href="#g" stroke="rgba(0,0,0,.1)" stroke-width=".25"/>
	</svg>
</main>

<script>
	var dot_flag = false;
						
	function dotPosition(){
		var map = document.getElementById("map");
		var s = document.getElementById("dot");
		var screenX = {{screen_x}} - 100.0;
		var screenY = {{screen_y}} - 100.0;
		var preX = {{x_coordinate}} - 50.0;
		var preY = {{y_coordinate}} - 50.0;
		
		var currentScreenX = map.offsetWidth - 100.0;
		var currentScreenY = map.offsetHeight - 100.0;
		
		var scale = currentScreenX/2000;
		
		var x = ((currentScreenX*preX)/screenX) + 50.0 - scale*s.offsetWidth/2;
		var y = ((currentScreenY*preY)/screenY) + 50.0 - scale*s.offsetHeight/2;
		
		s.style.width = scale*30 + "px";
		s.style.height = scale*30 + "px";
		s.style.transform = 'translate('+x+'px,'+y+'px)';
		//s.style.left = x + "px";
		//s.style.top = y + "px";
		dot_flag = true;
	}
						
	window.onload = dotPosition;
	
	if (!dot_flag)
		dotPosition();
</script>

<script src="https://hammerjs.github.io/dist/hammer.js"></script>
<script>
      var MIN_SCALE = 1; // 1=scaling when first loaded
      var MAX_SCALE = 64;
      // HammerJS fires "pinch" and "pan" events that are cumulative in nature and not
      // deltas. Therefore, we need to store the "last" values of scale, x and y so that we can
      // adjust the UI accordingly. It isn't until the "pinchend" and "panend" events are received
      // that we can set the "last" values.
      // Our "raw" coordinates are not scaled. This allows us to only have to modify our stored
      // coordinates when the UI is updated. It also simplifies our calculations as these
      // coordinates are without respect to the current scale.
   
      var img = null;
      var current = {x: 0, y: 0, zoom: 1, oldzoom: 1};
      var container = null;
      var table = null;
      var map = null;
      var prevScale = 1;
      var furn = null;
          // We need to disable the following event handlers so that the browser doesn't try to
      // automatically handle our image drag gestures.
      var disableImgEventHandlers = function() {
        var events = ['onclick', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover',
          'onmouseup', 'ondblclick', 'onfocus', 'onblur'
        ];
        events.forEach(function(event) {
          img[event] = function() {
            return false;
          };
        });
      };
    /*  
      class Furniture {
  constructor(meID,mapID) {
    this.img = document.getElementById(meID);
      this.container = document.getElementById(mapID);
      if(this.img.nodeName == "svg"){
         this.bBox = this.img.getBBox();
         this.imgWidth = this.bBox.width;
         this.imgHeight = this.bBox.height;
        // this.viewportWidth = this.container.offsetWidth;
      //this.viewportHeight = this.container.offsetHeight;
          //this.scale = this.viewportWidth / this.imgWidth;
          //this.lastScale = this.scale;
      //this.viewportHeight = this.container.height;
    
      }
      else{
        this.imgWidth = this.img.width;
        this.imgHeight = this.img.height;
       // this.viewportWidth = this.img.offsetWidth;
        //this.viewportHeight = this.img.offsetHeight;
          //this.scale = this.viewportWidth / this.imgWidth;
          //this.lastScale = this.scale;
      //this.viewportHeight = this.container.height;
       
      }
         this.viewportWidth = this.container.offsetWidth;
      this.viewportHeight = this.container.height;
          this.scale = this.viewportWidth / this.imgWidth;
          this.lastScale = this.scale;
        this.curWidth = this.imgWidth * this.scale;                     
        this.curHeight = this.imgHeight * this.scale;
      this.x = 0;
        this.lastX = 0;
        this.y = 0;
        this.lastY = 0;
        this.pinchCenter = null;
  }
   // Traverse the DOM to calculate the absolute position of an element
      absolutePosition (el){
        var x = 0,
          y = 0;
        while (el !== null) {
          x += el.offsetLeft;
          y += el.offsetTop;
          el = el.offsetParent;
        }
        return {
          x: x,
          y: y
        };
      };
      restrictScale(scale) {
        if (scale < 1) {
          scale = 1;
        } else if (scale > 64) {
          scale = 64;
        }
        return scale;
      };
      restrictRawPos(pos, viewportDim, imgDim) {
        if (pos < viewportDim / this.scale - imgDim) { // too far left/up?
          pos = viewportDim / this.scale - imgDim;
        } else if (pos > 0) { // too far right/down?
          pos = 0;
        }
        return pos;
      };
      updateLastPos (deltaX, deltaY) {
        //this.lastX = this.x;
        //this.lastY = this.y;
        this.lastX = this.x;
        this.lastY = this.y;
      };
      translate(deltaX, deltaY) {
        // We restrict to the min of the viewport width/height or current width/height as the
        // current width/height may be smaller than the viewport width/height
        var newX = this.restrictRawPos(this.lastX + deltaX / this.scale,
          Math.min(this.viewportWidth, this.curWidth), this.imgWidth);
        this.x = newX;
        this.img.style.marginLeft = Math.ceil(newX * this.scale) + 'px' ;
        var newY = this.restrictRawPos(this.lastY + deltaY / this.scale,
          Math.min(this.viewportHeight, this.curHeight), this.imgHeight);
        this.y = newY;
        this.img.style.marginTop = Math.ceil(newY * this.scale) + 'px' ;
      };
      zoom(scaleBy) {
        this.scale = this.restrictScale(this.lastScale * scaleBy);
        this.curWidth = this.imgWidth * this.scale;
        this.curHeight = this.imgHeight * this.scale;
        this.img.style.width = Math.ceil(this.curWidth) + 'px';
        this.img.style.height = Math.ceil(this.curHeight) + 'px' ;
        // Adjust margins to make sure that we aren't out of bounds
        this.translate(0, 0);
      };
      rawCenter(e) {
        var pos = this.absolutePosition(this.container);
        // We need to account for the scroll position
        var scrollLeft =  document.body.scrollLeft;
        var scrollTop =  document.body.scrollTop;
        var zoomX = -this.x + (e.center.x - pos.x + scrollLeft) / this.scale;
        var zoomY = -this.y + (e.center.y - pos.y + scrollTop) / this.scale;
        return { x: zoomX, y: zoomY };
      };
      updateLastScale() {
        this.lastScale = this.scale;
      };
      zoomAround(scaleBy, rawZoomX, rawZoomY, doNotUpdateLast) {
        // Zoom
       // this.zoom(scaleBy);
        // New raw center of viewport
        var rawCenterX = -this.x + Math.min(this.viewportWidth, this.curWidth) / 2 / this.scale;
        var rawCenterY = -this.y + Math.min(this.viewportHeight, this.curHeight) / 2 / this.scale;
        // Delta
        //var deltaX = (rawCenterX - rawZoomX) * this.scale;
        //var deltaY = (rawCenterY - rawZoomY) * this.scale;
        var deltaX = (rawCenterX - rawZoomX) ;
        var deltaY = (rawCenterY - rawZoomY) ;
        // Translate back to zoom center
       
        if (!doNotUpdateLast) {
          this.updateLastScale();
          this.updateLastPos();
        }
        return { x: deltaX, y: deltaY };
      };
      zoomCenter(scaleBy) {
        // Center of viewport
        var zoomX = -this.x + Math.min(this.viewportWidth, this.curWidth) / 2 / this.scale;
        var zoomY = -this.y + Math.min(this.viewportHeight, this.curHeight) / 2 / this.scale;
        this.zoomAround(scaleBy, zoomX, zoomY);
      };
      zoomIn() {
       this.zoomCenter(2);
      };
      zoomOut() {
        this.zoomCenter(1 / 2);
      };
}
*/
      var zoomWithTransform = function(e){
        var zoomImg = img,
        originalZoom = current.zoom,
        newZoom = current.zoom * 1.6, //put parameter for scale
        /// scroll offset
        scrollX = zoomImg.scrollLeft,
        scrollY = zoomImg.scrollTop,
        /// offset of containeR -- not sure if offset exists
        /// mouse cords
        mouseX = e.center.x - 0 + scrollX,
        mouseY = e.center.y - 0 + scrollY,
        /// calculate click at current zoom
        xCoord = (mouseX - current.x) / originalZoom,
        yCoord = (mouseY - current.y) / originalZoom,
        /// calculate click at new zoom
        newX = xCoord * newZoom,
        newY = yCoord * newZoom,
        /// move to the difference
        /// make sure we take mouse pointer offset into account!
        finalX = (xCoord + (mouseX - xCoord) - newX),
        finalY = (yCoord + (mouseY - yCoord) - newY)
        current.zoom = newZoom;
        current.x = finalX;
        current.y = finalY;
        current.oldzoom = originalZoom;
      }
      var zoomOut = function(e){
      	        var zoomImg = img;
        var originalZoom = current.zoom;
        if(originalZoom >1){
        newZoom = current.zoom * .75; //put parameter for scale
    }
        current.zoom = newZoom;
  //      current.x = finalX;
  //      current.y = finalY;
        current.oldzoom = originalZoom;
        img.style.transform
        = 'scale('+current.zoom+')';
        console.log( "Current values " + current.x + ' ' + current.y);
        var tempx = document.getElementById('map-container').scrollLeft;
        var tempy = document.getElementById('map-container').scrollTop;
        console.log("Current Scrolls " + tempx, tempy);
        var newScrollLeft =  -(current.x * current.zoom);
        var newScrollTop = -((current.y * current.zoom) );
        console.log(newScrollLeft, newScrollTop);
      //  document.getElementById('map-container').scrollLeft= tempx - newScrollLeft;
    //    document.getElementById('map-container').scrollTop= tempy - newScrollTop;
         furn.style.transform
        = 'scale('+current.zoom+')';
      
      }
  
      var onLoad = function() {
        img = document.getElementById("map");
        container = document.getElementById("map-container");
        furn = document.getElementById("furniture");
        
      //  table = new Furniture("furniture", "map-container");
       // map = new Furniture("map", "map-container");
 
      //  disableImgEventHandlers();
        var hammer = new Hammer(container, {
          domEvents: true
        });
        hammer.get('pinch').set({
          enable: true
        });
        hammer.on('pan', function(e) {
          //map.translate(e.deltaX, e.deltaY);
          //table.translate(e.deltaX, e.deltaY);
        });
        hammer.on('panend', function(e) {
         // map.updateLastPos();
         // table.updateLastPos();
        });
        hammer.on('pinch', function(e) {
          // We only calculate the pinch center on the first pinch event as we want the center to
          // stay consistent during the entire pinch
          //if (pinchCenter === null) {
           // pinchCenter = rawCenter(e);
           // var offsetX = pinchCenter.x * scale - (-x * scale + Math.min(viewportWidth, curWidth) / 2);
           // var offsetY = pinchCenter.y * scale - (-y * scale + Math.min(viewportHeight, curHeight) / 2);
           // pinchCenterOffset = {
           //   x: offsetX,
           //   y: offsetY
           // };
          //}
        //  var newScale = restrictScale(scale * e.scale);
        //  var zoomX = pinchCenter.x * newScale - pinchCenterOffset.x;
         // var zoomY = pinchCenter.y * newScale - pinchCenterOffset.y;
         // var zoomCenter = {
         //   x: zoomX / newScale,
          //  y: zoomY / newScale
         // };
        
          
        });
        hammer.on('pinchend', function(e) {
       //   updateLastScale();
       //   updateLastPos();
       //   pinchCenter = null;
        });
        hammer.on('doubletap', function(e) {
          //var c = map.rawCenter(e);
          //var n = map.zoomAround(1.6, c.x, c.y);
          //var n = table.rawCenter(e);
          //table.zoomAround(1.6, n.x, n.y);
          //var newScale = 1.3*prevScale;
          zoomWithTransform(e);    
          //apply new transformations
          img.style.transform
        = 'scale('+current.zoom+')';
        console.log(current.x + ' ' + current.y);
        var tempx = document.getElementById('map-container').scrollLeft;
        var tempy = document.getElementById('map-container').scrollTop;
        document.getElementById('map-container').scrollLeft= -(current.x * current.zoom);
        document.getElementById('map-container').scrollTop= -((current.y * current.zoom) );
         furn.style.transform
        = 'scale('+current.zoom+')';
       //prevScale = newScale;
        });
      };
      onLoad();
</script>

</body>
</html>